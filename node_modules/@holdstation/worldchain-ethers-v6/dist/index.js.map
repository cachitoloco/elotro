{"version":3,"sources":["../src/codec.ts","../src/client.ts","../src/multicall3.ts"],"names":["EthersCodec","abi","ethers","fnName","args","data","EthersClient","provider","logger","n","e","address","value","length","hexValue","filter","log","o","hash","tx","method","values","EthersMulticall3","config","calls","block","item"],"mappings":"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","file":"index.js","sourcesContent":["import { AbiCodec } from \"@holdstation/worldchain-sdk\";\nimport { ethers } from \"ethers\";\n\nexport class EthersCodec implements AbiCodec {\n  private iface: ethers.Interface;\n\n  constructor(abi: any[]) {\n    this.iface = new ethers.Interface(abi);\n  }\n\n  encodeFunctionData(fnName: string, args: unknown[] = []): string {\n    return this.iface.encodeFunctionData(fnName, args);\n  }\n\n  decodeFunctionResult(fnName: string, data: string) {\n    return this.iface.decodeFunctionResult(fnName, data);\n  }\n}\n","import { AbiCodec, Client, FilterLogs, logger, OnchainTransaction, Result } from \"@holdstation/worldchain-sdk\";\nimport { ethers } from \"ethers\";\nimport { EthersCodec } from \"./codec\";\n\nexport class EthersClient implements Client {\n  private _chainId: number = 0;\n\n  constructor(private readonly provider: ethers.JsonRpcProvider) {\n    if (!provider?._network?.chainId) {\n      logger.warn(\"ChainId is not set, please set it by using `ethers.JsonRpcProvider`\");\n\n      this.provider\n        .getNetwork()\n        .then((n) => (this._chainId = Number(n.chainId)))\n        .catch((e) => logger.error(\"Error getting chainId\", e));\n    } else {\n      this._chainId = Number(provider._network.chainId);\n    }\n  }\n\n  name(): string {\n    return \"ethers-client\";\n  }\n\n  isValidAddress(address: string): boolean {\n    return ethers.isAddress(address);\n  }\n\n  hexZeroPad(value: string, length: number): string {\n    // In ethers v6, hexZeroPad is now in the ethers.zeroPadValue function\n    // The signature has changed to take a BytesLike and return a \"0x\"-prefixed string\n    let hexValue = value;\n\n    // Make sure the value has '0x' prefix\n    if (!hexValue.startsWith(\"0x\")) {\n      hexValue = \"0x\" + hexValue;\n    }\n\n    return ethers.zeroPadValue(value, length);\n  }\n\n  async getBlockNumber() {\n    return this.provider.getBlockNumber();\n  }\n\n  getChainId() {\n    return this._chainId;\n  }\n\n  getProvider() {\n    return this.provider;\n  }\n\n  async getLogs(filter: Partial<FilterLogs[\"request\"]>): Promise<FilterLogs[\"response\"][]> {\n    const logs = await this.provider.getLogs(filter);\n\n    return logs.map((log) => ({\n      blockNumber: log.blockNumber,\n      blockHash: log.blockHash,\n      transactionIndex: log.transactionIndex,\n      removed: log.removed,\n      address: log.address,\n      data: log.data,\n\n      // ya, this a bit weird, but ethers v6 has a new type for topics\n      // which is `Array<string | null>`, but we need to convert it to `Array<string>`\n      // so we need map it to string\n      topics: log.topics.map((o) => o.toString()),\n\n      transactionHash: log.transactionHash,\n      logIndex: log.index,\n    }));\n  }\n\n  async getTransaction(hash: string): Promise<OnchainTransaction> {\n    const tx = await this.provider.getTransaction(hash);\n    if (!tx) {\n      throw new Error(`Transaction with hash ${hash} not found`);\n    }\n\n    return {\n      hash: tx.hash,\n      to: tx.to ?? undefined,\n      from: tx.from,\n      nonce: tx.nonce,\n      gasLimit: tx.gasLimit.toString(),\n      gasPrice: tx.gasPrice?.toString(),\n      data: tx.data,\n      value: tx.value.toString(),\n      blockNumber: tx.blockNumber ?? undefined,\n      blockHash: tx.blockHash ?? undefined,\n      timestamp: undefined,\n    };\n  }\n\n  encodeFunctionData(abi: string[], method: string, values?: any[]): string {\n    const iface = new ethers.Interface(abi);\n    return iface.encodeFunctionData(method, values);\n  }\n\n  decodeFunctionResult(abi: string[], method: string, data: string): Result {\n    const iface = new ethers.Interface(abi);\n    return iface.decodeFunctionResult(method, data);\n  }\n\n  codec(abi: any): AbiCodec {\n    // TODO: cached codec\n    return new EthersCodec(abi);\n  }\n}\n","import { Aggregate, Aggregate3, Multicall3, abi, config } from \"@holdstation/worldchain-sdk\";\nimport { ethers } from \"ethers\";\n\nexport class EthersMulticall3 implements Multicall3 {\n  private readonly contract: ethers.Contract;\n\n  constructor(provider: ethers.JsonRpcProvider) {\n    this.contract = new ethers.Contract(config.multicall3Address, abi.MULTICALL3_JSONABI, provider);\n  }\n\n  async aggregate(calls: Aggregate[\"request\"][]): Promise<Aggregate[\"response\"]> {\n    const [block, data] = await this.contract.aggregate(calls);\n    return [Number(block), data];\n  }\n\n  async aggregate3(calls: Aggregate3[\"request\"][]): Promise<Aggregate3[\"response\"][]> {\n    // Multicall3.aggregate3 only returns the results array, not a block number\n    const results = await this.contract.aggregate3(calls);\n\n    return results.map((item: any) => {\n      return {\n        returnData: item.returnData,\n        success: item.success,\n      };\n    });\n  }\n}\n"]}