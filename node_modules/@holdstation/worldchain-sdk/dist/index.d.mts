import * as _worldcoin_minikit_js from '@worldcoin/minikit-js';
import BigNumber from 'bignumber.js';

declare const DEX_ABI: ({
    type: string;
    stateMutability: string;
    name?: undefined;
    inputs?: undefined;
    outputs?: undefined;
    anonymous?: undefined;
} | {
    type: string;
    name: string;
    inputs: {
        name: string;
        type: string;
        internalType: string;
    }[];
    outputs: {
        name: string;
        type: string;
        internalType: string;
    }[];
    stateMutability: string;
    anonymous?: undefined;
} | {
    type: string;
    name: string;
    inputs: ({
        name: string;
        type: string;
        internalType: string;
        components: ({
            name: string;
            type: string;
            internalType: string;
            components: {
                name: string;
                type: string;
                internalType: string;
            }[];
        } | {
            name: string;
            type: string;
            internalType: string;
            components?: undefined;
        })[];
    } | {
        name: string;
        type: string;
        internalType: string;
        components?: undefined;
    })[];
    outputs: never[];
    stateMutability: string;
    anonymous?: undefined;
} | {
    type: string;
    name: string;
    inputs: {
        name: string;
        type: string;
        indexed: boolean;
        internalType: string;
    }[];
    anonymous: boolean;
    stateMutability?: undefined;
    outputs?: undefined;
} | {
    type: string;
    name: string;
    inputs: {
        name: string;
        type: string;
        internalType: string;
    }[];
    stateMutability?: undefined;
    outputs?: undefined;
    anonymous?: undefined;
})[];

declare const ERC20_ABI: ({
    constant: boolean;
    inputs: {
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        name: string;
        type: string;
    }[];
    payable: boolean;
    stateMutability: string;
    type: string;
    anonymous?: undefined;
} | {
    payable: boolean;
    stateMutability: string;
    type: string;
    constant?: undefined;
    inputs?: undefined;
    name?: undefined;
    outputs?: undefined;
    anonymous?: undefined;
} | {
    anonymous: boolean;
    inputs: {
        indexed: boolean;
        name: string;
        type: string;
    }[];
    name: string;
    type: string;
    constant?: undefined;
    outputs?: undefined;
    payable?: undefined;
    stateMutability?: undefined;
})[];

declare const MULTICALL3_JSONABI: {
    inputs: ({
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    })[];
    name: string;
    outputs: ({
        internalType: string;
        name: string;
        type: string;
        components?: undefined;
    } | {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    })[];
    stateMutability: string;
    type: string;
}[];

declare const uniswapQuoterV2ABI: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    name?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
} | {
    inputs: {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
})[];

declare const uniswapRouterV2ABI: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    name?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
} | {
    stateMutability: string;
    type: string;
    inputs?: undefined;
    name?: undefined;
    outputs?: undefined;
})[];

declare const uniswapRouterV3ABI: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    name?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
} | {
    inputs: {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
} | {
    stateMutability: string;
    type: string;
    inputs?: undefined;
    name?: undefined;
    outputs?: undefined;
})[];

declare const viewQuoterv3ABI: ({
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
    name?: undefined;
    outputs?: undefined;
} | {
    inputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
} | {
    inputs: {
        components: {
            internalType: string;
            name: string;
            type: string;
        }[];
        internalType: string;
        name: string;
        type: string;
    }[];
    name: string;
    outputs: {
        internalType: string;
        name: string;
        type: string;
    }[];
    stateMutability: string;
    type: string;
})[];

declare const index_DEX_ABI: typeof DEX_ABI;
declare const index_ERC20_ABI: typeof ERC20_ABI;
declare const index_MULTICALL3_JSONABI: typeof MULTICALL3_JSONABI;
declare const index_uniswapQuoterV2ABI: typeof uniswapQuoterV2ABI;
declare const index_uniswapRouterV2ABI: typeof uniswapRouterV2ABI;
declare const index_uniswapRouterV3ABI: typeof uniswapRouterV3ABI;
declare const index_viewQuoterv3ABI: typeof viewQuoterv3ABI;
declare namespace index {
  export { index_DEX_ABI as DEX_ABI, index_ERC20_ABI as ERC20_ABI, index_MULTICALL3_JSONABI as MULTICALL3_JSONABI, index_uniswapQuoterV2ABI as uniswapQuoterV2ABI, index_uniswapRouterV2ABI as uniswapRouterV2ABI, index_uniswapRouterV3ABI as uniswapRouterV3ABI, index_viewQuoterv3ABI as viewQuoterv3ABI };
}

interface AbiCodec {
    encodeFunctionData(fnName: string, args?: unknown[]): string;
    decodeFunctionResult(fnName: string, data: string): Result$1;
}
interface Result$1 extends ReadonlyArray<any> {
    readonly [key: string]: any;
}

type FilterLogs = {
    request: {
        address: string;
        topics: Array<string | Array<string> | null>;
        fromBlock: string | number;
        toBlock: string | number;
    };
    response: {
        blockNumber: number;
        blockHash: string;
        transactionIndex: number;
        removed: boolean;
        address: string;
        data: string;
        topics: Array<string>;
        transactionHash: string;
        logIndex: number;
    };
};
type OnchainTransaction = {
    hash?: string;
    to?: string;
    from?: string;
    nonce: number;
    gasLimit: string;
    gasPrice?: string;
    data: string;
    value: string;
    blockNumber?: number;
    blockHash?: string;
    timestamp?: number;
    raw?: string;
};
interface Result extends ReadonlyArray<any> {
    readonly [key: string]: any;
}
interface Client {
    name(): string;
    isValidAddress(address: string): boolean;
    hexZeroPad(value: string, length: number): string;
    getBlockNumber: () => Promise<number>;
    getChainId: () => number;
    getLogs(filter: Partial<FilterLogs["request"]>): Promise<FilterLogs["response"][]>;
    getTransaction(hash: string): Promise<OnchainTransaction>;
    codec(abi: any): AbiCodec;
}

type Aggregate = {
    request: {
        target: string;
        callData: string;
    };
    response: [blockNumber: number, returnData: string[]];
};
type Aggregate3 = {
    request: {
        target: string;
        allowFailure: boolean;
        callData: string;
    };
    response: {
        returnData: string;
        success: boolean;
    };
};
interface Multicall3 {
    aggregate(calls: Aggregate["request"][]): Promise<Aggregate["response"]>;
    aggregate3(calls: Aggregate3["request"][]): Promise<Aggregate3["response"][]>;
}

declare class Config {
    multicall3Address: string;
    private _client;
    private _multicall3;
    constructor();
    get client(): Client;
    set client(client: Client);
    get multicall3(): Multicall3;
    set multicall3(multicall3: Multicall3);
}
declare const config: Config;

type Token = {
    address: string;
    name: string;
    symbol: string;
    decimals: number;
    chainId: number;
};
interface TokenStorage {
    save(token: Token): Promise<void>;
    findByAddress(address: string): Promise<Token>;
    find(addresses: string[]): Promise<Token[]>;
}

declare class IdbTokenStorage implements TokenStorage {
    private db;
    constructor(dbName?: string);
    save(token: Token): Promise<void>;
    findByAddress(address: string): Promise<Token>;
    find(addresses: string[]): Promise<Token[]>;
}

declare enum TransactionStatus {
    NotDefined = 0,
    Fail = 1,
    Success = 2
}
type ExtractedTransaction = {
    hash: string;
    to: string;
    block: number;
    success: TransactionStatus;
};
type Transfer = {
    tokenAddress: string;
    amount: string;
    from: string;
    to: string;
};
type CalculatedTransactionField = {
    date?: Date;
    method: string;
    protocol: string;
    transfers: Transfer[];
};
type Transaction = ExtractedTransaction & CalculatedTransactionField;
interface TransactionStorage {
    save(transaction: Transaction): Promise<void>;
    find(offset: number, limit: number): Promise<Transaction[]>;
    findByHash(hash: string): Promise<Transaction>;
    findLastBlock(): Promise<number>;
    findMinBlock(): Promise<number>;
    saveMultiple(transactions: Transaction[]): Promise<void>;
}

declare class IndexedDBTransactionStorageImpl implements TransactionStorage {
    private db;
    constructor(dbName?: string);
    save(transaction: Transaction): Promise<void>;
    saveMultiple(transactions: Transaction[]): Promise<void>;
    find(offset: number, limit: number): Promise<Transaction[]>;
    findByHash(hash: string): Promise<Transaction>;
    findLastBlock(): Promise<number>;
    findMinBlock(): Promise<number>;
}

declare class InmemoryTokenStorage implements TokenStorage {
    private store;
    save(token: Token): Promise<void>;
    findByAddress(address: string): Promise<Token>;
    find(addresses: string[]): Promise<Token[]>;
}
declare const inmemoryTokenStorage: InmemoryTokenStorage;

declare class InmemoryTransactionStorageImpl implements TransactionStorage {
    saveMultiple(transactions: Transaction[]): Promise<void>;
    save(transaction: Transaction): Promise<void>;
    find(offset: number, limit: number): Promise<Transaction[]>;
    findByHash(hash: string): Promise<Transaction>;
    findLastBlock(): Promise<number>;
    findMinBlock(): Promise<number>;
}
declare const inmemoryTransactionStorage: InmemoryTransactionStorageImpl;

type BalanceOfWalletTokens = {
    wallet: string;
    tokens: string[];
};
type BalanceOfTokenWallets = {
    token: string;
    wallets: string[];
};
declare class TokenProvider {
    private readonly client;
    private readonly multicall3;
    private readonly storage;
    constructor(params?: Partial<{
        client: Client;
        multicall3: Multicall3;
        storage: TokenStorage;
    }>);
    details(...tokenAddresses: string[]): Promise<Record<string, Token>>;
    tokenOf(wallet: string, options?: {
        blockPerRequest: number;
        toBlock?: number;
        fromBlock?: number;
    }): Promise<string[]>;
    balanceOf(params: BalanceOfTokenWallets | BalanceOfWalletTokens): Promise<Record<string, string>>;
    private balanceOfWalletTokens;
    private balanceOfTokenWallets;
}

declare class Manager {
    private listeners;
    private readonly mutex;
    private readonly client;
    private readonly tokenProvider;
    private readonly tokenStorage;
    private readonly transactionStorage;
    constructor(options?: Partial<{
        client: Client;
        tokenProvider: TokenProvider;
        storage: Partial<{
            token: TokenStorage;
            tx: TransactionStorage;
        }>;
    }>);
    watch: (address: string, fromBlock: number, toBlock: number) => Promise<{
        start: () => Promise<void>;
        stop: () => Promise<void>;
    }>;
}

declare enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3,
    LOG = 4,
    TRACE = 5,
    NONE = 6
}
declare class Logger {
    private logLevel;
    private prefix;
    setLogLevel(level: LogLevel): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    log(...args: any[]): void;
    trace(...args: any[]): void;
}
declare const logger: Logger;

/**
 * @typedef SendNativeParams
 * @property {number} amount - The amount of native cryptocurrency (e.g., ETH) to send.
 *                             This value is typically specified in the base unit (e.g., Ether).
 * @property {string} to - The recipient's address to which the native cryptocurrency will be sent.
 *                         This should be a valid Ethereum address.
 */
type SendNativeParams = {
    amount: number;
    to: string;
};
/**
 * @typedef SendERC20Params
 * @property {number} amount - The amount of ERC20 tokens to send.
 *                             This value is typically specified in the token's base unit (e.g., smallest divisible unit like wei for ETH-based tokens).
 * @property {string} token - The contract address of the ERC20 token to be sent.
 *                            This should be a valid Ethereum address representing the token contract.
 * @property {string} to - The recipient's address to which the ERC20 tokens will be sent.
 *                         This should be a valid Ethereum address.
 */
type SendERC20Params = {
    amount: number;
    token: string;
    to: string;
};
declare class Sender {
    private readonly spender;
    private readonly tokenProvider;
    constructor(tokenProvider?: TokenProvider);
    /**
     * Sends native cryptocurrency (e.g., ETH) to a specified address.
     * @private
     * @param {SendNativeParams} params - Parameters for sending native cryptocurrency.
     * @returns {Promise<any>} - Transaction payload.
     */
    private native;
    /**
     * Sends ERC20 tokens to a specified address.
     * @param {SendERC20Params} params - Parameters for sending ERC20 tokens.
     * @returns {Promise<any>} - Transaction payload.
     */
    private erc20;
    send(params: SendNativeParams | SendERC20Params): Promise<{
        commandPayload: _worldcoin_minikit_js.SendTransactionInput | null;
        finalPayload: _worldcoin_minikit_js.MiniAppSendTransactionPayload;
    }>;
}

declare function isStableCoin(address: string, stableCoins: string[]): boolean;
declare function isNativeToken(address: string): boolean;
/**
 * Determines the fee type (in or out) based on token types.
 * @param tokenIn - The input token address.
 * @param tokenOut - The output token address.
 */
declare function getFeeDirect(tokenIn: string, tokenOut: string, stableCoins: string[], priotizeAddress?: string): 0 | 1;
/**
 * Calculates the fee for a given input amount.
 * @param tokenOut - The output token address.
 * @param amountIn - The input amount in Wei.
 * @param fee - The fee percentage.
 */
declare function getFeeWithAmountIn(tokenOut: string, amountIn: BigNumber, fee: number): {
    feePercent: string;
    feeAmount?: undefined;
    feeToken?: undefined;
} | {
    feeAmount: string;
    feeToken: number;
    feePercent?: undefined;
};
/**
 * Calculates the fee for a given output amount.
 * @param amountOut - The output amount in Wei.
 * @param fee - The fee percentage.
 */
declare function getFeeWithAmountOut(amountOut: string, fee: number): {
    feeAmount: string;
    feeToken: number;
};

declare const defaultWorldchainConfig: SwapConfig;
type SwapParams = {
    quoteInput: {
        tokenIn: string;
        tokenOut: string;
        amountIn: string;
        slippage?: string;
        fee?: string;
        feeReceiver?: string;
        preferRouters?: string[];
        timeout?: number;
    };
    quoteOutput: {
        data: string;
        to: string;
        value?: string;
        addons?: {
            /**
             * The estimated output token amount after the swap.
             */
            outAmount: string;
            /**
             * The swap rate between the input and output tokens.
             */
            rateSwap: string;
            /**
             * The output token amount in USD.
             */
            amountOutUsd: string;
            /**
             * The minimum output amount after considering slippage and fees.
             */
            minReceived: string;
            /**
             * The fee amount deducted from the output in hexadecimal format.
             */
            feeAmountOut: string;
        };
    };
    input: {
        tokenIn: string;
        tokenOut: string;
        amountIn: string;
        tx: {
            data: string;
            to: string;
            value?: string;
        };
        feeAmountOut?: string;
        fee?: string;
        feeReceiver?: string;
        partnerCode?: string;
    };
    output: {
        success: boolean;
        errorCode?: string;
        transactionId?: string;
    };
};
type SwapConfig = {
    tokens: {
        weth: Token;
        wld: Token;
        eth: Token;
    };
    uniswap: {
        router: {
            v2: string;
            v3: string;
        };
        quoter: {
            v2: string;
        };
    };
    stableCoins: string[];
    spender: string;
    tokenStorage?: TokenStorage;
    tradeSurplusRecipient?: string;
};
interface Estimator {
    quote(input: SwapParams["quoteInput"]): Promise<SwapParams["quoteOutput"]>;
}
interface Swapper {
    swap(input: SwapParams["input"]): Promise<SwapParams["output"]>;
    estimate: Estimator;
    load(swapModule: SwapModule): Promise<void>;
}
interface SwapModule {
    estimate: Estimator["quote"];
    name(): string;
    enabled(chainId: number): boolean;
}

declare class HoldSo implements SwapModule {
    private readonly tokenProvider;
    private readonly tokenStorage;
    private config;
    constructor(tokenProvider: TokenProvider, tokenStorage: TokenStorage, config?: Partial<SwapConfig>);
    name(): string;
    enabled(chainId: number): boolean;
    private holdSoSwapRequest;
    estimate(params: SwapParams["quoteInput"]): Promise<SwapParams["quoteOutput"]>;
    private findToken;
}

declare class SwapHelper implements Swapper {
    private readonly client;
    private modules;
    private readonly tokenProvider;
    private tokenStorage;
    estimate: Estimator;
    private config;
    constructor(client: Client, config?: Partial<SwapConfig>);
    /**
     * Loads the necessary dependencies for the SwapHelper.
     * @param swapModule - The swap module containing dependencies to initialize.
     */
    load(swapModule: SwapModule): Promise<void>;
    private _quote;
    swap(params: SwapParams["input"]): Promise<SwapParams["output"]>;
    private submitSwapTokensForTokens;
    private submitSwapETHForTokens;
    private submitSwapTokensForETH;
    /**
     * Finds token details by its address, either from storage or by fetching from the provider.
     * @param tokenAddress - The address of the token.
     */
    private findToken;
    private packPartnerData;
}

declare class ZeroX implements SwapModule {
    private readonly tokenProvider;
    private readonly tokenStorage;
    private config;
    constructor(tokenProvider: TokenProvider, tokenStorage: TokenStorage, config?: Partial<SwapConfig>);
    name(): string;
    enabled(chainId: number): boolean;
    private zeroXRequest;
    private tokenRateUsd;
    estimate(params: SwapParams["quoteInput"]): Promise<SwapParams["quoteOutput"]>;
    private findToken;
}

/**
 * Sets the partner code for tracking purposes
 * @param {string} code - The partner code to set
 * @returns {boolean} True if the code was successfully set
 */
declare const setPartnerCode: (code: string) => boolean;
/**
 * Gets the current partner code
 * @returns {string|null} The partner code or null if not set
 */
declare const getPartnerCode: () => string | null;
/**
 * Clears the partner code from memory and persistent storage if available
 * @returns {boolean} True if the code was successfully cleared
 */
declare const clearPartnerCode: () => boolean;
/**
 * Initialize a check that periodically warns if partner code is not set
 * Called automatically when this module is imported
 */
declare const initPartnerCodeCheck: () => void;

export { type AbiCodec, type Aggregate, type Aggregate3, type Client, DEX_ABI, ERC20_ABI, type Estimator, type FilterLogs, HoldSo, IdbTokenStorage, IndexedDBTransactionStorageImpl, MULTICALL3_JSONABI, Manager, type Multicall3, type OnchainTransaction, type Result, type SendERC20Params, type SendNativeParams, Sender, type SwapConfig, SwapHelper, type SwapModule, type SwapParams, type Swapper, type Token, TokenProvider, type TokenStorage, type Transaction, TransactionStatus, type TransactionStorage, ZeroX, index as abi, clearPartnerCode, config, defaultWorldchainConfig, getFeeDirect, getFeeWithAmountIn, getFeeWithAmountOut, getPartnerCode, initPartnerCodeCheck, inmemoryTokenStorage, inmemoryTransactionStorage, isNativeToken, isStableCoin, logger, setPartnerCode, uniswapQuoterV2ABI, uniswapRouterV2ABI, uniswapRouterV3ABI, viewQuoterv3ABI };
