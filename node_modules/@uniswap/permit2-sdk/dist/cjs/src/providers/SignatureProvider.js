"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureProvider = void 0;
const tslib_1 = require("tslib");
const bignumber_1 = require("@ethersproject/bignumber");
const contracts_1 = require("@ethersproject/contracts");
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
const Permit2_json_1 = tslib_1.__importDefault(require("../../abis/Permit2.json"));
class SignatureProvider {
    constructor(provider, permit2Address) {
        this.provider = provider;
        this.permit2Address = permit2Address;
        this.permit2 = new contracts_1.Contract(this.permit2Address, Permit2_json_1.default, this.provider);
    }
    /**
     * Check if a nonce has been used for signature transfers
     * @param owner The owner address
     * @param nonce The nonce to check
     * @returns true if the nonce has been used, false otherwise
     */
    isNonceUsed(owner, nonce) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { wordPos, bitPos } = SignatureProvider.getNoncePositions(nonce);
            const bitmap = yield this.permit2.nonceBitmap(owner, wordPos);
            return SignatureProvider.isBitSet(bitmap, bitPos);
        });
    }
    /**
     * Check if a permit has expired based on its deadline
     * @param deadline The deadline timestamp
     * @returns true if the permit has expired, false otherwise
     */
    isExpired(deadline) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currentTimestamp = yield this.getCurrentTimestamp();
            return bignumber_1.BigNumber.from(deadline).lt(currentTimestamp);
        });
    }
    /**
     * Check if a permit is valid (not expired and nonce not used)
     * @param permit The permit data to validate
     * @returns true if the permit is valid, false otherwise
     */
    isPermitValid(permit) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.validatePermit(permit)).isValid;
        });
    }
    /**
     * Get detailed validation results for a permit
     * @param permit The permit data to validate
     * @returns Object containing validation results
     */
    validatePermit(permit) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [isExpiredResult, isNonceUsedResult] = yield Promise.all([
                this.isExpired(permit.deadline),
                this.isNonceUsed(permit.spender, permit.nonce),
            ]);
            return {
                isUsed: isNonceUsedResult,
                isExpired: isExpiredResult,
                isValid: !isExpiredResult && !isNonceUsedResult,
            };
        });
    }
    /**
     * Get the current nonce bitmap for an owner at a specific word position
     * @param owner The owner address
     * @param wordPos The word position in the bitmap
     * @returns The bitmap as a BigNumber
     */
    getNonceBitmap(owner, wordPos) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.permit2.nonceBitmap(owner, wordPos);
        });
    }
    /**
     * Check if a specific bit is set in the nonce bitmap
     * @param bitmap The bitmap to check
     * @param bitPos The bit position (0-255)
     * @returns true if the bit is set, false otherwise
     */
    static isBitSet(bitmap, bitPos) {
        (0, tiny_invariant_1.default)(bitPos >= 0 && bitPos <= 255, 'BIT_POSITION_OUT_OF_RANGE');
        const mask = bignumber_1.BigNumber.from(1).shl(bitPos);
        return bitmap.and(mask).gt(0);
    }
    /**
     * Get the word position and bit position for a given nonce
     * @param nonce The nonce to analyze
     * @returns Object containing wordPos and bitPos
     */
    static getNoncePositions(nonce) {
        const nonceBN = bignumber_1.BigNumber.from(nonce);
        return {
            wordPos: nonceBN.shr(8),
            bitPos: nonceBN.and(255).toNumber(),
        };
    }
    /**
     * Batch check multiple nonces for the same owner
     * @param owner The owner address
     * @param nonces Array of nonces to check
     * @returns Array of boolean results indicating if each nonce is used
     */
    batchCheckNonces(owner, nonces) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Get unique word positions to minimize contract calls
            const wordPositions = new Set();
            nonces.forEach((nonce) => {
                const { wordPos } = SignatureProvider.getNoncePositions(nonce);
                wordPositions.add(wordPos.toString());
            });
            // Fetch all required bitmaps
            const bitmapPromises = Array.from(wordPositions).map((wordPosKey) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const wordPos = bignumber_1.BigNumber.from(wordPosKey);
                const bitmap = yield this.getNonceBitmap(owner, wordPos);
                return { wordPos, bitmap };
            }));
            const bitmaps = yield Promise.all(bitmapPromises);
            const bitmapMap = new Map(bitmaps.map(({ wordPos, bitmap }) => [wordPos.toString(), bitmap]));
            // Check each nonce
            return nonces.map((nonce) => {
                const { wordPos, bitPos } = SignatureProvider.getNoncePositions(nonce);
                const bitmap = bitmapMap.get(wordPos.toString());
                if (!bitmap) {
                    throw new Error(`Bitmap not found for word position ${wordPos.toString()}`);
                }
                return SignatureProvider.isBitSet(bitmap, bitPos);
            });
        });
    }
    /**
     * Get the current block timestamp
     * @returns Current block timestamp
     */
    getCurrentTimestamp() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const currentBlock = yield this.provider.getBlock('latest');
            return currentBlock.timestamp;
        });
    }
}
exports.SignatureProvider = SignatureProvider;
//# sourceMappingURL=SignatureProvider.js.map